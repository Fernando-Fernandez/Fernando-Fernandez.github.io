<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Salesforce Integration Patterns - Mini Periodic Table</title>
  <style>
    :root{
      --bg:#ffffff;
      --panel:#f6f7fb;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#4b5563;
      --border:rgba(15,23,42,.08);
      --shadow: 0 8px 20px rgba(15,23,42,.08);
      --radius:14px;
      --gap:10px;

      /* Pattern accent colors */
      --req:#5dd6ff;
      --faf:#ffcf5d;
      --batch:#7dff9a;
      --remote:#c28bff;
      --virt:#ff6fae;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
      background: var(--bg);
      color:var(--text);
      padding:16px;
    }

    header{
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      margin-bottom:12px;
    }

    h1{
      font-size:18px;
      margin:0 0 6px 0;
      font-weight:700;
      letter-spacing:.2px;
    }
    .sub{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
      max-width: 70ch;
    }

    .legend{
      display:flex;
      flex-wrap:wrap;
      gap:6px 8px;
      align-items:center;
      justify-content:flex-end;
      margin-top:2px;
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:4px 8px;
      background: rgba(15,23,42,.04);
      border:1px solid var(--border);
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      user-select:none;
      white-space:nowrap;
    }
    .dot{
      width:10px; height:10px;
      border-radius:50%;
      background: var(--muted);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
    }

    .layout{
      display:grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    .table{
      background: #fff;
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .tableHeader{
      display:grid;
      grid-template-columns: repeat(5, minmax(120px, 1fr));
      gap:6px;
      padding:6px;
      background: linear-gradient(180deg, rgba(15,23,42,.04), rgba(15,23,42,.02));
      border-bottom:1px solid var(--border);
    }
    .colHead{
      padding:10px;
      font-weight:700;
      font-size:12px;
      letter-spacing:.5px;
      text-transform:uppercase;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .colHead .dot{ box-shadow:none; }

    .grid{
      display:grid;
      grid-template-columns: repeat(5, minmax(120px, 1fr));
      gap:6px;
      padding:6px;
    }

    .cell{
      padding:0;
      border:1px solid var(--border);
      min-height: 160px;
      background: rgba(15,23,42,.02);
      display:flex;
      justify-content:center;
      align-items:flex-start;
      border-radius: 12px;
    }

    .stack{
      width:100%;
      max-width:100%;
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:6px;
      align-content:flex-start;
    }

    .card{
      position:relative;
      background: var(--card-color, var(--card));
      border:none;
      border-radius: 12px;
      padding:5px 5px 5px 5px;
      cursor:pointer;
      transition: transform .18s ease, box-shadow .18s ease;
      outline:none;
      box-shadow: 0 10px 22px rgba(15,23,42,.12);
      color: #0b1220;
      width:100%;
      min-height: var(--card-height, 110px);
      display:flex;
      flex-direction:column;
      gap:6px;
      overflow:hidden;
    }
    .card:hover{
      transform: translateY(-3px);
      box-shadow: 0 16px 26px rgba(15,23,42,.18);
    }

    .bar{
      position:absolute;
      left:0; top:0; bottom:0;
      width:4px;
      border-top-left-radius:12px;
      border-bottom-left-radius:12px;
      background: var(--muted);
      opacity:.95;
    }

    .row{
      display:block;
      flex-shrink:0;
      min-width:0;
    }
    .name{
      font-weight:700;
      font-size:13px;
      line-height:1.25;
      color:#fff;
      text-shadow:0 1px 2px rgba(0,0,0,.35);
      white-space:normal;
      word-break:break-word;
    }
    .desc{
      margin-top:4px;
      font-size:12px;
      color:rgba(12,23,42,.9);
      line-height:1.35;
      flex:1 1 auto;
      overflow:hidden;
      word-break:break-word;
    }

    /* Modal */
    dialog{
      width:min(620px, calc(100% - 32px));
      border:none;
      padding:0;
      background: transparent;
    }
    dialog::backdrop{
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(4px);
    }
    .modal{
      background: whitesmoke;
      border:1px solid rgba(15,23,42,.08);
      border-radius: 18px;
      box-shadow: 0 24px 70px rgba(15,23,42,.25);
      overflow:hidden;
    }
    .modalTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      padding:16px 16px 12px 16px;
      border-bottom:1px solid rgba(15,23,42,.06);
      background: linear-gradient(180deg, rgba(255,255,255,1), rgba(255,255,255,.8));
    }
    .modalTitle{
      margin:0;
      font-size:16px;
      font-weight:800;
      line-height:1.2;
    }
    .modalMeta{
      margin:6px 0 0 0;
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    .closeBtn{
      appearance:none;
      border:1px solid rgba(15,23,42,.12);
      background: rgba(15,23,42,.06);
      color:var(--text);
      border-radius: 12px;
      padding:8px 10px;
      cursor:pointer;
      font-size:12px;
    }
    .closeBtn:hover{ border-color: rgba(15,23,42,.26); }

    .modalBody{
      padding:14px 16px 16px 16px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .section{
      border:1px solid rgba(15,23,42,.08);
      background: #fff;
      border-radius: 14px;
      padding:12px;
    }
    .section h3{
      margin:0 0 8px 0;
      font-size:12px;
      letter-spacing:.4px;
      text-transform:uppercase;
      color:var(--text);
    }
    .section p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.5;
    }
    .list{
      margin:0;
      padding-left:18px;
      color:var(--muted);
      font-size:13px;
      line-height:1.55;
    }

    /* Responsive */
    @media (max-width: 1020px){
      .tableHeader, .grid{ grid-template-columns: repeat(2, minmax(140px, 1fr)); }
      .cell:nth-child(2n){ border-right:none; }
      .cell:nth-child(5n){ border-right:1px solid var(--border); } /* neutralize */
    }
    @media (max-width: 560px){
      .tableHeader, .grid{ grid-template-columns: 1fr; }
      .cell{ border-right:none; }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Mini Periodic Table - Salesforce Integration Patterns</h1>
      <p class="sub">
        Click any card for a detailed view. Hover shows a quick tip. Cards can repeat across patterns.
      </p>
    </div>
    <div class="legend" aria-label="Legend">
      <span class="pill"><span class="dot" style="background:var(--req)"></span>Request & Response</span>
      <span class="pill"><span class="dot" style="background:var(--faf)"></span>Fire & Forget</span>
      <span class="pill"><span class="dot" style="background:var(--batch)"></span>Batch Integration</span>
      <span class="pill"><span class="dot" style="background:var(--remote)"></span>Remote Call In</span>
      <span class="pill"><span class="dot" style="background:var(--virt)"></span>Virtualization</span>
    </div>
  </header>

  <main class="layout">
    <section class="table" aria-label="Periodic table grid">
      <div class="tableHeader">
        <div class="colHead"><span class="dot" style="background:var(--req)"></span>Request & Response</div>
        <div class="colHead"><span class="dot" style="background:var(--faf)"></span>Fire & Forget</div>
        <div class="colHead"><span class="dot" style="background:var(--batch)"></span>Batch Integration</div>
        <div class="colHead"><span class="dot" style="background:var(--remote)"></span>Remote Call In</div>
        <div class="colHead"><span class="dot" style="background:var(--virt)"></span>Virtualization</div>
      </div>

      <div class="grid" id="grid"></div>
    </section>
  </main>

  <dialog id="detailDialog" aria-label="Card details">
    <div class="modal">
      <div class="modalTop">
        <div>
          <h2 class="modalTitle" id="modalTitle">Title</h2>
          <p class="modalMeta" id="modalMeta">Meta</p>
        </div>
        <button class="closeBtn" id="closeBtn" type="button">Close</button>
      </div>
      <div class="modalBody">
        <div class="section">
          <h3>What it is</h3>
          <p id="modalWhat"></p>
        </div>
        <div class="section">
          <h3>How it fits this pattern</h3>
          <ul class="list" id="modalFit"></ul>
        </div>
        <div class="section">
          <h3>Typical usage context</h3>
          <ul class="list" id="modalUse"></ul>
        </div>
      </div>
    </div>
  </dialog>

  <script>
    // Pattern definitions (for color + layout)
    const PATTERNS = [
      { key: "req",   label: "Request & Response", colorVar: "--req" },
      { key: "faf",   label: "Fire & Forget",      colorVar: "--faf" },
      { key: "batch", label: "Batch Integration",  colorVar: "--batch" },
      { key: "remote",label: "Remote Call In",     colorVar: "--remote" },
      { key: "virt",  label: "Virtualization",     colorVar: "--virt" },
    ];

    // Cards can repeat across patterns: include multiple entries with different pattern keys.
    // Keep these concise; you can expand later.
    const CARD_DEFS = [
      // Request & Response
      {
        name: "Lightning Platform REST API",
        abbr: "REST",
        patterns: ["req","remote"],
        detail: {
          what: "Salesforce core REST API for platform resources.",
          fit: ["Synchronous request/response over HTTP.", "Often used by web/mobile/backends to CRUD and query data."],
          use: ["When caller needs immediate result.", "When you want broad ecosystem support and simple contracts."]
        }
      },
      {
        name: "Lightning Platform SOAP API",
        abbr: "SOAP",
        patterns: ["req","remote"],
        detail: {
          what: "SOAP-based API for platform resources.",
          fit: ["Strong schema and enterprise tooling fit.", "Synchronous call model (with async patterns layered on top)."],
          use: ["When WSDL-driven clients and strict schemas are preferred.", "When legacy enterprise integration tooling expects SOAP."]
        }
      },
      {
        name: "Apex Web Services",
        abbr: "AWS",
        patterns: ["req","remote"],
        detail: {
          what: "Expose Apex classes as REST or SOAP services.",
          fit: ["External systems call into Salesforce-hosted logic.", "Still request/response at transport level."],
          use: ["When you must enforce org-side business rules on inbound calls.", "When you need a custom contract beyond standard objects."]
        }
      },
      {
        name: "User Interface API",
        abbr: "UI",
        patterns: ["req"],
        detail: {
          what: "API for building Salesforce UI experiences in custom apps.",
          fit: ["Synchronous retrieval of UI metadata, layouts, and data needed to render screens."],
          use: ["When you want Salesforce-consistent UI behavior outside standard UI.", "Mobile or custom web apps needing layout-aware rendering."]
        }
      },
      {
        name: "Connect REST API",
        abbr: "C-REST",
        patterns: ["req"],
        detail: {
          what: "API surface including Chatter and collaboration constructs.",
          fit: ["Interactive, synchronous operations for collaboration features."],
          use: ["Intranet/mobile integrations that need feeds, comments, users, groups."]
        }
      },
      {
        name: "Reports and Dashboards REST API",
        abbr: "RPT",
        patterns: ["req"],
        detail: {
          what: "Programmatic access to reports and dashboard results.",
          fit: ["Client requests a report result set; response returned."],
          use: ["Embedding analytics in portals/apps.", "Automating exports and scheduled retrieval patterns."]
        }
      },
      {
        name: "Platform Encryption REST API",
        abbr: "ENC",
        patterns: ["req"],
        detail: {
          what: "Manage tenant secrets outside of Salesforce.",
          fit: ["Direct calls to manage encryption secrets and related operations."],
          use: ["Security operations workflows.", "Compliance-driven key management integrations."]
        }
      },

      // Fire & Forget
      {
        name: "Platform Events",
        abbr: "PE",
        patterns: ["faf"],
        detail: {
          what: "Custom event bus for business events.",
          fit: ["Publisher emits events; subscribers process asynchronously.", "Designed for decoupling and fan-out."],
          use: ["Notify downstream systems of business happenings.", "Integrate microservices without tight coupling."]
        }
      },
      {
        name: "Change Data Capture",
        abbr: "CDC",
        patterns: ["faf"],
        detail: {
          what: "Real-time notifications for record changes.",
          fit: ["Change stream consumed asynchronously.", "Optimized for data-change events rather than business events."],
          use: ["Sync downstream databases/search indexes.", "Trigger external processes on create/update/delete/undelete."]
        }
      },
      {
        name: "Streaming API",
        abbr: "STR",
        patterns: ["faf"],
        detail: {
          what: "Subscription-based event delivery over streaming channels.",
          fit: ["Subscriber model aligns with fire & forget consumption.", "Transports platform events and CDC."],
          use: ["Near-real-time integrations where clients maintain subscriptions."]
        }
      },
      {
        name: "Workflow Outbound Message",
        abbr: "WOM",
        patterns: ["faf"],
        detail: {
          what: "Workflow-driven outbound notifications to endpoints.",
          fit: ["Asynchronous notification pattern (business success handled externally)."],
          use: ["Simple outbound integration when eventing is sufficient.", "Legacy-friendly outbound notifications."]
        }
      },

      // Batch
      {
        name: "Bulk API 2.0",
        abbr: "B2",
        patterns: ["batch"],
        detail: {
          what: "REST-based bulk load and bulk query operations.",
          fit: ["Job-based lifecycle (submit, monitor, retrieve results).", "Throughput optimized over latency."],
          use: ["Large migrations, nightly ETL, mass updates.", "When you must respect API limits via bulk mechanics."]
        }
      },
      {
        name: "Customer 360 Data Manager Data Jobs API",
        abbr: "C360J",
        patterns: ["batch"],
        detail: {
          what: "Create and run Customer 360 Data Manager jobs via REST.",
          fit: ["Job orchestration and batch execution.", "Async job controls and status polling."],
          use: ["Batch harmonization/processing within Customer 360 data pipelines."]
        }
      },

      // Remote Call In (some repeated across columns)
      {
        name: "Salesforce Knowledge Developer API",
        abbr: "KN",
        patterns: ["remote","req"],
        detail: {
          what: "Build knowledge base integrations via multiple platform APIs.",
          fit: ["Commonly used by external systems calling into Salesforce to manage knowledge assets."],
          use: ["Knowledge publishing workflows that originate outside Salesforce."]
        }
      },

      // Virtualization
      {
        name: "Salesforce Connect",
        abbr: "SC",
        patterns: ["virt"],
        detail: {
          what: "External objects and data access without copying data into Salesforce.",
          fit: ["External data appears native; queries delegated outward."],
          use: ["When data must remain in source of truth.", "When you accept latency/availability tradeoffs for freshness."]
        }
      },
      {
        name: "OData Adapters",
        abbr: "OData",
        patterns: ["virt"],
        detail: {
          what: "OData adapters used by Salesforce Connect.",
          fit: ["Standard protocol for external data virtualization."],
          use: ["When exposing external data via OData endpoints to Salesforce Connect."]
        }
      },
      {
        name: "Data Federation API",
        abbr: "DFA",
        patterns: ["virt"],
        detail: {
          what: "OData REST API for federated queries against queryable data models.",
          fit: ["Federated query surface: query across data without centralizing it."],
          use: ["When you need unified querying across multiple stores/models."]
        }
      },
      {
        name: "Federated Search API",
        abbr: "FSA",
        patterns: ["virt"],
        detail: {
          what: "Connects federated search connectors to external systems.",
          fit: ["Virtualized search over external sources rather than ingesting content."],
          use: ["Enterprise search scenarios where indexing is external or constrained."]
        }
      },
      {
        name: "Files Connect",
        abbr: "FC",
        patterns: ["virt"],
        detail: {
          what: "Access external files (e.g., Drive/SharePoint) inside Salesforce.",
          fit: ["Content stays external; Salesforce provides in-context access."],
          use: ["When file governance requires external storage but Salesforce needs visibility."]
        }
      },
      
      // Request & Response
      {
        name: "Apex Callouts",
        abbr: "CALL",
        patterns: ["req"],
        detail: {
          what: "Outbound HTTP call capability from Apex.",
          fit: ["Synchronous request/response initiated from Salesforce.", "Tightly coupled to Apex execution context."],
          use: ["Calling external REST/SOAP services from triggers, flows, or async Apex.", "Server-side integrations requiring Salesforce-originated calls."]
        }
      },
      {
        name: "Metadata API",
        abbr: "META",
        patterns: ["req","remote","batch"],
        detail: {
          what: "API for managing Salesforce metadata programmatically.",
          fit: ["Deployment-style operations with async execution.", "Org configuration as data."],
          use: ["CI/CD pipelines.", "Automated org setup, packaging, and migrations."]
        }
      },
      {
        name: "Tooling API",
        abbr: "TOOL",
        patterns: ["req","remote"],
        detail: {
          what: "API for building custom development and admin tooling.",
          fit: ["Low-level access to Apex, metadata, and tooling objects."],
          use: ["Custom IDEs, linters, code analyzers.", "Advanced admin automation and inspection tools."]
        }
      },

      // Commerce APIs
      {
        name: "B2B Commerce API",
        abbr: "B2BC",
        patterns: ["req"],
        detail: {
          what: "APIs for building B2B commerce experiences.",
          fit: ["Synchronous commerce operations.", "Catalog, pricing, and buyer workflows."],
          use: ["Custom storefronts.", "ERP or partner commerce integrations."]
        }
      },
      {
        name: "B2C Commerce API",
        abbr: "B2CC",
        patterns: ["req"],
        detail: {
          what: "Headless commerce APIs for B2C experiences.",
          fit: ["High-throughput synchronous calls.", "Decoupled frontend architectures."],
          use: ["Mobile apps and headless storefronts.", "Custom checkout and catalog flows."]
        }
      },
      {
        name: "B2C Commerce Einstein API",
        abbr: "E-COM",
        patterns: ["req"],
        detail: {
          what: "ML-driven personalization APIs for commerce.",
          fit: ["Real-time recommendation and personalization calls."],
          use: ["Personalized search, ranking, and recommendations."]
        }
      },

      // Customer 360 / CDP
      {
        name: "Salesforce CDP API",
        abbr: "CDP",
        patterns: ["req","batch"],
        detail: {
          what: "APIs for Customer Data Platform operations.",
          fit: ["Profile, ingestion, and segmentation operations."],
          use: ["Activating unified customer data.", "Feeding downstream personalization systems."]
        }
      },
      {
        name: "Customer 360",
        abbr: "C360",
        patterns: ["virt","batch"],
        detail: {
          what: "Unified data layer across Salesforce clouds.",
          fit: ["Data harmonization and identity resolution."],
          use: ["Cross-cloud analytics and personalization."]
        }
      },

      // Marketing APIs
      {
        name: "Marketing Cloud API",
        abbr: "MC",
        patterns: ["req","batch"],
        detail: {
          what: "APIs for Salesforce Marketing Cloud.",
          fit: ["Campaign, journey, and messaging operations."],
          use: ["Cross-channel marketing automation.", "External campaign orchestration."]
        }
      },
      {
        name: "Marketing Cloud Einstein Content Selection API",
        abbr: "MC-EIN",
        patterns: ["req"],
        detail: {
          what: "AI-driven content selection for Marketing Cloud.",
          fit: ["Low-latency personalization calls."],
          use: ["Dynamic content selection in campaigns."]
        }
      },
      {
        name: "Pardot / Account Engagement API",
        abbr: "AE",
        patterns: ["req","batch"],
        detail: {
          what: "B2B marketing automation APIs.",
          fit: ["Lead, prospect, and engagement data access."],
          use: ["Sales-marketing data sync.", "External lead enrichment."]
        }
      },
      {
        name: "Social Studio API",
        abbr: "SOC",
        patterns: ["req","batch"],
        detail: {
          what: "APIs for social media management and analytics.",
          fit: ["Content and engagement data retrieval."],
          use: ["Social listening and reporting integrations."]
        }
      },

      // Einstein AI
      {
        name: "Einstein Platform Services API",
        abbr: "EIN",
        patterns: ["req"],
        detail: {
          what: "Custom ML model inference APIs.",
          fit: ["Real-time prediction calls."],
          use: ["Embedding AI predictions into CRM workflows."]
        }
      },
      {
        name: "Einstein Bot API",
        abbr: "BOT",
        patterns: ["req","faf"],
        detail: {
          what: "APIs for building and integrating Einstein Bots.",
          fit: ["Conversational request/response with async events."],
          use: ["Chat and messaging channel integrations."]
        }
      },

      // Analytics
      {
        name: "Tableau CRM REST API",
        abbr: "TCRM",
        patterns: ["req"],
        detail: {
          what: "API for Tableau CRM (Einstein Analytics).",
          fit: ["Querying datasets and dashboards."],
          use: ["Embedding analytics in apps and portals."]
        }
      },

      // Service & Knowledge
      {
        name: "Omni-Channel API",
        abbr: "OMNI",
        patterns: ["req","faf"],
        detail: {
          what: "APIs for Omni-Channel routing and work assignment.",
          fit: ["Real-time routing with async updates."],
          use: ["Custom service consoles.", "Advanced routing logic integrations."]
        }
      },

      // Location
      {
        name: "Salesforce Maps REST API",
        abbr: "MAPS",
        patterns: ["req"],
        detail: {
          what: "Location intelligence and visualization APIs.",
          fit: ["Geospatial queries and route optimization."],
          use: ["Territory planning.", "Field service optimization."]
        }
      },

      // Collaboration
      {
        name: "Quip Automation API",
        abbr: "QUIP-A",
        patterns: ["req","faf"],
        detail: {
          what: "Automation and bot APIs for Quip.",
          fit: ["Document-centric workflows with async triggers."],
          use: ["Collaborative workflow automation."]
        }
      },
      {
        name: "Quip Live Apps API",
        abbr: "QUIP-L",
        patterns: ["req"],
        detail: {
          what: "UI extension APIs for Quip documents.",
          fit: ["Interactive embedded applications."],
          use: ["Custom collaborative experiences."]
        }
      },

      // Application Integration
      {
        name: "Canvas / Connected App",
        abbr: "CAN",
        patterns: ["req"],
        detail: {
          what: "Framework for embedding external apps in Salesforce UI.",
          fit: ["OAuth-based trust with iframe embedding."],
          use: ["Integrating existing web apps into Salesforce."]
        }
      },
      {
        name: "Lightning Out",
        abbr: "LO",
        patterns: ["req"],
        detail: {
          what: "Embed Lightning components in external apps.",
          fit: ["UI reuse outside Salesforce runtime."],
          use: ["Sharing Salesforce UI components externally."]
        }
      }
    ];

    const CARDS = CARD_DEFS.map(def => mk(def.name, def.abbr, def.patterns, def.detail));

    function mk(name, abbr, patterns, detail){
      return {
        id: (name + "|" + patterns.join(",")).toLowerCase().replace(/[^a-z0-9|,]+/g,"-"),
        name, abbr, patterns,
        tip: detail.fit?.[0] || "Click for details",
        detail
      };
    }

    // Build 5 columns. Each cell contains cards whose patterns include that column key.
    const grid = document.getElementById("grid");
    const cells = PATTERNS.map(p => {
      const el = document.createElement("div");
      el.className = "cell";
      el.dataset.pattern = p.key;

      const stack = document.createElement("div");
      stack.className = "stack";
      el.appendChild(stack);

      grid.appendChild(el);
      return { pattern: p, cell: el, stack };
    });

    const byPattern = new Map(PATTERNS.map(p => [p.key, []]));
    for(const c of CARDS){
      for(const pk of c.patterns){
        if(byPattern.has(pk)) byPattern.get(pk).push(c);
      }
    }

    // Render cards into each column cell
    for(const {pattern, stack} of cells){
      const items = byPattern.get(pattern.key) || [];
      // Sort stable by name for readability
      items.sort((a,b) => a.name.localeCompare(b.name));
      for(const item of items){
        stack.appendChild(renderCard(item, pattern));
      }
    }

    function renderCard(item, pattern){
      const card = document.createElement("button");
      card.type = "button";
      card.className = "card";
      card.style.setProperty("--card-color", `var(${pattern.colorVar})`);
      card.setAttribute("title", item.tip);
      card.dataset.cardId = item.id;
      card.dataset.pattern = pattern.key;

      const bar = document.createElement("div");
      bar.className = "bar";
      bar.style.background = `var(${pattern.colorVar})`;
      card.appendChild(bar);

      const row = document.createElement("div");
      row.className = "row";
      const name = document.createElement("div");
      name.className = "name";
      name.textContent = item.name;

      row.appendChild(name);
      card.appendChild(row);

      const desc = document.createElement("div");
      desc.className = "desc";
      desc.textContent = item.detail.what;
      card.appendChild(desc);

      card.addEventListener("click", () => {
        const rect = card.getBoundingClientRect();
        openModal(item, pattern, rect);
      });
      return card;
    }

    // Modal wiring
    const dlg = document.getElementById("detailDialog");
    const modalTitle = document.getElementById("modalTitle");
    const modalMeta = document.getElementById("modalMeta");
    const modalWhat = document.getElementById("modalWhat");
    const modalFit = document.getElementById("modalFit");
    const modalUse = document.getElementById("modalUse");
    const closeBtn = document.getElementById("closeBtn");
    const modalShell = dlg.querySelector(".modal");

    function openModal(item, pattern, sourceRect){
      modalTitle.textContent = item.name;
      modalMeta.textContent = `Opened from pattern: ${pattern.label} | Card key: ${item.abbr}`;
      modalWhat.textContent = item.detail.what;

      fillList(modalFit, item.detail.fit || []);
      fillList(modalUse, item.detail.use || []);

      if(typeof dlg.showModal === "function"){
        dlg.showModal();
        requestAnimationFrame(() => animateModalOpening(sourceRect));
      }
      else alert(item.name + "\n\n" + item.detail.what);
    }

    function fillList(el, lines){
      el.innerHTML = "";
      for(const line of lines){
        const li = document.createElement("li");
        li.textContent = line;
        el.appendChild(li);
      }
      if(lines.length === 0){
        const li = document.createElement("li");
        li.textContent = "No notes yet.";
        el.appendChild(li);
      }
    }

    closeBtn.addEventListener("click", () => dlg.close());
    dlg.addEventListener("click", (e) => {
      // close when clicking backdrop
      const rect = dlg.getBoundingClientRect();
      const inDialog = e.clientX >= rect.left && e.clientX <= rect.right &&
                       e.clientY >= rect.top && e.clientY <= rect.bottom;
      if(!inDialog) dlg.close();
    });

    function animateModalOpening(sourceRect){
      if(!sourceRect || !modalShell || typeof modalShell.animate !== "function") return;
      const modalRect = modalShell.getBoundingClientRect();
      const originX = clamp(((sourceRect.left + sourceRect.width / 2) - modalRect.left) / modalRect.width);
      const originY = clamp(((sourceRect.top + sourceRect.height / 2) - modalRect.top) / modalRect.height);
      const origin = `${originX * 100}% ${originY * 100}%`;

      modalShell.animate(
        [
          { transformOrigin: origin, transform: "scale(0.6)", opacity: 0, filter: "blur(6px)" },
          { transformOrigin: origin, transform: "scale(1)", opacity: 1, filter: "blur(0)" }
        ],
        {
          duration: 360,
          easing: "cubic-bezier(0.16, 1, 0.3, 1)"
        }
      );
    }

    function clamp(value, min = 0, max = 1){
      return Math.min(Math.max(value, min), max);
    }

    // ðŸ˜¼ Quick critical-thinking hooks (optional): uncomment to see pattern overlaps in console
    // console.table(CARDS.map(c => ({ name: c.name, patterns: c.patterns.join(", ") })));
  </script>
</body>
</html>
