<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Salesforce Integration Patterns - Mini Periodic Table</title>
  <style>
    :root{
      --bg:#ffffff;
      --panel:#f6f7fb;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#4b5563;
      --border:rgba(15,23,42,.08);
      --shadow: 0 12px 30px rgba(15,23,42,.08);
      --radius:14px;
      --gap:14px;

      /* Pattern accent colors */
      --req:#5dd6ff;
      --faf:#ffcf5d;
      --batch:#7dff9a;
      --remote:#c28bff;
      --virt:#ff6fae;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
      background: var(--bg);
      color:var(--text);
      padding:24px;
    }

    header{
      display:flex;
      gap:16px;
      align-items:flex-start;
      justify-content:space-between;
      margin-bottom:18px;
    }

    h1{
      font-size:18px;
      margin:0 0 6px 0;
      font-weight:700;
      letter-spacing:.2px;
    }
    .sub{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
      max-width: 70ch;
    }

    .legend{
      display:flex;
      flex-wrap:wrap;
      gap:8px 10px;
      align-items:center;
      justify-content:flex-end;
      margin-top:2px;
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      background: rgba(15,23,42,.04);
      border:1px solid var(--border);
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      user-select:none;
      white-space:nowrap;
    }
    .dot{
      width:10px; height:10px;
      border-radius:50%;
      background: var(--muted);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
    }

    .layout{
      display:grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    .table{
      background: #fff;
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .tableHeader{
      display:grid;
      grid-template-columns: minmax(182px, 1.3fr) repeat(4, minmax(140px, 1fr));
      gap:0;
      background: linear-gradient(180deg, rgba(15,23,42,.04), rgba(15,23,42,.02));
      border-bottom:1px solid var(--border);
    }
    .colHead{
      padding:12px 12px;
      font-weight:700;
      font-size:12px;
      letter-spacing:.5px;
      text-transform:uppercase;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .colHead .dot{ box-shadow:none; }

    .grid{
      display:grid;
      grid-template-columns: minmax(182px, 1.3fr) repeat(4, minmax(140px, 1fr));
      gap:0;
    }

    .cell{
      padding:12px;
      border-right:1px solid var(--border);
      border-bottom:1px solid var(--border);
      min-height: 160px;
      background: rgba(15,23,42,.02);
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .cell:nth-child(5n){ border-right:none; } /* last col */

    .stack{
      width:100%;
      max-width: var(--stack-max-width, 160px);
      display:grid;
      grid-template-columns: repeat(var(--card-columns, 1), minmax(120px, 1fr));
      gap:10px;
      margin:0 auto;
      align-content:flex-start;
    }

    .card{
      position:relative;
      background: var(--card-color, var(--card));
      border:none;
      border-radius: 12px;
      padding:12px 12px 12px 16px;
      cursor:pointer;
      transition: transform .18s ease, box-shadow .18s ease;
      outline:none;
      box-shadow: 0 10px 22px rgba(15,23,42,.12);
      color: #0b1220;
      width:100%;
      height: var(--card-height, 160px);
      display:flex;
      flex-direction:column;
      gap:8px;
      overflow:hidden;
    }
    .card:hover{
      transform: translateY(-3px);
      box-shadow: 0 16px 26px rgba(15,23,42,.18);
    }

    .bar{
      position:absolute;
      left:0; top:0; bottom:0;
      width:4px;
      border-top-left-radius:12px;
      border-bottom-left-radius:12px;
      background: var(--muted);
      opacity:.95;
    }

    .row{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-shrink:0;
      min-width:0;
    }
    .name{
      font-weight:700;
      font-size:13px;
      line-height:1.25;
      color:#fff;
      text-shadow:0 1px 2px rgba(0,0,0,.35);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .abbr{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      color:#fff;
      opacity:.95;
      padding:2px 6px;
      border-radius:999px;
      background: rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.25);
      user-select:none;
      flex-shrink:0;
      align-self:flex-start;
    }
    .desc{
      margin-top:6px;
      font-size:12px;
      color:rgba(12,23,42,.9);
      line-height:1.35;
      flex:1 1 auto;
      display:-webkit-box;
      -webkit-line-clamp:4;
      -webkit-box-orient:vertical;
      overflow:hidden;
    }

    /* Modal */
    dialog{
      width:min(620px, calc(100% - 32px));
      border:none;
      padding:0;
      background: transparent;
    }
    dialog::backdrop{
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(4px);
    }
    .modal{
      background: whitesmoke;
      border:1px solid rgba(15,23,42,.08);
      border-radius: 18px;
      box-shadow: 0 24px 70px rgba(15,23,42,.25);
      overflow:hidden;
    }
    .modalTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      padding:16px 16px 12px 16px;
      border-bottom:1px solid rgba(15,23,42,.06);
      background: linear-gradient(180deg, rgba(255,255,255,1), rgba(255,255,255,.8));
    }
    .modalTitle{
      margin:0;
      font-size:16px;
      font-weight:800;
      line-height:1.2;
    }
    .modalMeta{
      margin:6px 0 0 0;
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    .closeBtn{
      appearance:none;
      border:1px solid rgba(15,23,42,.12);
      background: rgba(15,23,42,.06);
      color:var(--text);
      border-radius: 12px;
      padding:8px 10px;
      cursor:pointer;
      font-size:12px;
    }
    .closeBtn:hover{ border-color: rgba(15,23,42,.26); }

    .modalBody{
      padding:14px 16px 16px 16px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .section{
      border:1px solid rgba(15,23,42,.08);
      background: #fff;
      border-radius: 14px;
      padding:12px;
    }
    .section h3{
      margin:0 0 8px 0;
      font-size:12px;
      letter-spacing:.4px;
      text-transform:uppercase;
      color:var(--text);
    }
    .section p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.5;
    }
    .list{
      margin:0;
      padding-left:18px;
      color:var(--muted);
      font-size:13px;
      line-height:1.55;
    }

    /* Responsive */
    @media (max-width: 1020px){
      .tableHeader, .grid{ grid-template-columns: repeat(2, minmax(140px, 1fr)); }
      .cell:nth-child(2n){ border-right:none; }
      .cell:nth-child(5n){ border-right:1px solid var(--border); } /* neutralize */
    }
    @media (max-width: 560px){
      .tableHeader, .grid{ grid-template-columns: 1fr; }
      .cell{ border-right:none; }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Mini Periodic Table - Salesforce Integration Patterns</h1>
      <p class="sub">
        Click any card for a detailed view. Hover shows a quick tip. Cards can repeat across patterns.
      </p>
    </div>
    <div class="legend" aria-label="Legend">
      <span class="pill"><span class="dot" style="background:var(--req)"></span>Request & Response</span>
      <span class="pill"><span class="dot" style="background:var(--faf)"></span>Fire & Forget</span>
      <span class="pill"><span class="dot" style="background:var(--batch)"></span>Batch Integration</span>
      <span class="pill"><span class="dot" style="background:var(--remote)"></span>Remote Call In</span>
      <span class="pill"><span class="dot" style="background:var(--virt)"></span>Virtualization</span>
    </div>
  </header>

  <main class="layout">
    <section class="table" aria-label="Periodic table grid">
      <div class="tableHeader">
        <div class="colHead"><span class="dot" style="background:var(--req)"></span>Request & Response</div>
        <div class="colHead"><span class="dot" style="background:var(--faf)"></span>Fire & Forget</div>
        <div class="colHead"><span class="dot" style="background:var(--batch)"></span>Batch Integration</div>
        <div class="colHead"><span class="dot" style="background:var(--remote)"></span>Remote Call In</div>
        <div class="colHead"><span class="dot" style="background:var(--virt)"></span>Virtualization</div>
      </div>

      <div class="grid" id="grid"></div>
    </section>
  </main>

  <dialog id="detailDialog" aria-label="Card details">
    <div class="modal">
      <div class="modalTop">
        <div>
          <h2 class="modalTitle" id="modalTitle">Title</h2>
          <p class="modalMeta" id="modalMeta">Meta</p>
        </div>
        <button class="closeBtn" id="closeBtn" type="button">Close</button>
      </div>
      <div class="modalBody">
        <div class="section">
          <h3>What it is</h3>
          <p id="modalWhat"></p>
        </div>
        <div class="section">
          <h3>How it fits this pattern</h3>
          <ul class="list" id="modalFit"></ul>
        </div>
        <div class="section">
          <h3>Typical usage context</h3>
          <ul class="list" id="modalUse"></ul>
        </div>
      </div>
    </div>
  </dialog>

  <script>
    // Pattern definitions (for color + layout)
    const PATTERNS = [
      { key: "req",   label: "Request & Response", colorVar: "--req" },
      { key: "faf",   label: "Fire & Forget",      colorVar: "--faf" },
      { key: "batch", label: "Batch Integration",  colorVar: "--batch" },
      { key: "remote",label: "Remote Call In",     colorVar: "--remote" },
      { key: "virt",  label: "Virtualization",     colorVar: "--virt" },
    ];

    // Cards can repeat across patterns: include multiple entries with different pattern keys.
    // Keep these concise; you can expand later.
    const CARDS = [
      // Request & Response
      mk("Lightning Platform REST API", "REST", ["req","remote"], {
        what: "Salesforce core REST API for platform resources.",
        fit: ["Synchronous request/response over HTTP.", "Often used by web/mobile/backends to CRUD and query data."],
        use: ["When caller needs immediate result.", "When you want broad ecosystem support and simple contracts."]
      }),
      mk("Lightning Platform SOAP API", "SOAP", ["req","remote"], {
        what: "SOAP-based API for platform resources.",
        fit: ["Strong schema and enterprise tooling fit.", "Synchronous call model (with async patterns layered on top)."],
        use: ["When WSDL-driven clients and strict schemas are preferred.", "When legacy enterprise integration tooling expects SOAP."]
      }),
      mk("Apex Web Services", "AWS", ["req","remote"], {
        what: "Expose Apex classes as REST or SOAP services.",
        fit: ["External systems call into Salesforce-hosted logic.", "Still request/response at transport level."],
        use: ["When you must enforce org-side business rules on inbound calls.", "When you need a custom contract beyond standard objects."]
      }),
      mk("User Interface API", "UI", ["req"], {
        what: "API for building Salesforce UI experiences in custom apps.",
        fit: ["Synchronous retrieval of UI metadata, layouts, and data needed to render screens."],
        use: ["When you want Salesforce-consistent UI behavior outside standard UI.", "Mobile or custom web apps needing layout-aware rendering."]
      }),
      mk("Connect REST API", "C-REST", ["req"], {
        what: "API surface including Chatter and collaboration constructs.",
        fit: ["Interactive, synchronous operations for collaboration features."],
        use: ["Intranet/mobile integrations that need feeds, comments, users, groups."]
      }),
      mk("Reports and Dashboards REST API", "RPT", ["req"], {
        what: "Programmatic access to reports and dashboard results.",
        fit: ["Client requests a report result set; response returned."],
        use: ["Embedding analytics in portals/apps.", "Automating exports and scheduled retrieval patterns."]
      }),
      mk("Platform Encryption REST API", "ENC", ["req"], {
        what: "Manage tenant secrets outside of Salesforce.",
        fit: ["Direct calls to manage encryption secrets and related operations."],
        use: ["Security operations workflows.", "Compliance-driven key management integrations."]
      }),

      // Fire & Forget
      mk("Platform Events", "PE", ["faf"], {
        what: "Custom event bus for business events.",
        fit: ["Publisher emits events; subscribers process asynchronously.", "Designed for decoupling and fan-out."],
        use: ["Notify downstream systems of business happenings.", "Integrate microservices without tight coupling."]
      }),
      mk("Change Data Capture", "CDC", ["faf"], {
        what: "Real-time notifications for record changes.",
        fit: ["Change stream consumed asynchronously.", "Optimized for data-change events rather than business events."],
        use: ["Sync downstream databases/search indexes.", "Trigger external processes on create/update/delete/undelete."]
      }),
      mk("Streaming API", "STR", ["faf"], {
        what: "Subscription-based event delivery over streaming channels.",
        fit: ["Subscriber model aligns with fire & forget consumption.", "Transports platform events and CDC."],
        use: ["Near-real-time integrations where clients maintain subscriptions."]
      }),
      mk("Workflow Outbound Message", "WOM", ["faf"], {
        what: "Workflow-driven outbound notifications to endpoints.",
        fit: ["Asynchronous notification pattern (business success handled externally)."],
        use: ["Simple outbound integration when eventing is sufficient.", "Legacy-friendly outbound notifications."]
      }),

      // Batch
      mk("Bulk API 2.0", "B2", ["batch"], {
        what: "REST-based bulk load and bulk query operations.",
        fit: ["Job-based lifecycle (submit, monitor, retrieve results).", "Throughput optimized over latency."],
        use: ["Large migrations, nightly ETL, mass updates.", "When you must respect API limits via bulk mechanics."]
      }),
      mk("Customer 360 Data Manager Data Jobs API", "C360J", ["batch"], {
        what: "Create and run Customer 360 Data Manager jobs via REST.",
        fit: ["Job orchestration and batch execution.", "Async job controls and status polling."],
        use: ["Batch harmonization/processing within Customer 360 data pipelines."]
      }),

      // Remote Call In (some repeated across columns)
      mk("Salesforce Knowledge Developer API", "KN", ["remote","req"], {
        what: "Build knowledge base integrations via multiple platform APIs.",
        fit: ["Commonly used by external systems calling into Salesforce to manage knowledge assets."],
        use: ["Knowledge publishing workflows that originate outside Salesforce."]
      }),

      // Virtualization
      mk("Salesforce Connect", "SC", ["virt"], {
        what: "External objects and data access without copying data into Salesforce.",
        fit: ["External data appears native; queries delegated outward."],
        use: ["When data must remain in source of truth.", "When you accept latency/availability tradeoffs for freshness."]
      }),
      mk("OData Adapters", "OData", ["virt"], {
        what: "OData adapters used by Salesforce Connect.",
        fit: ["Standard protocol for external data virtualization."],
        use: ["When exposing external data via OData endpoints to Salesforce Connect."]
      }),
      mk("Data Federation API", "DFA", ["virt"], {
        what: "OData REST API for federated queries against queryable data models.",
        fit: ["Federated query surface: query across data without centralizing it."],
        use: ["When you need unified querying across multiple stores/models."]
      }),
      mk("Federated Search API", "FSA", ["virt"], {
        what: "Connects federated search connectors to external systems.",
        fit: ["Virtualized search over external sources rather than ingesting content."],
        use: ["Enterprise search scenarios where indexing is external or constrained."]
      }),
      mk("Files Connect", "FC", ["virt"], {
        what: "Access external files (e.g., Drive/SharePoint) inside Salesforce.",
        fit: ["Content stays external; Salesforce provides in-context access."],
        use: ["When file governance requires external storage but Salesforce needs visibility."]
      }),
    ];

    function mk(name, abbr, patterns, detail){
      return {
        id: (name + "|" + patterns.join(",")).toLowerCase().replace(/[^a-z0-9|,]+/g,"-"),
        name, abbr, patterns,
        tip: detail.fit?.[0] || "Click for details",
        detail
      };
    }

    // Build 5 columns. Each cell contains cards whose patterns include that column key.
    const grid = document.getElementById("grid");
    const cells = PATTERNS.map(p => {
      const el = document.createElement("div");
      el.className = "cell";
      el.dataset.pattern = p.key;

      const stack = document.createElement("div");
      stack.className = "stack";
      const isRequestColumn = p.key === "req";
      stack.style.setProperty("--card-columns", isRequestColumn ? 2 : 1);
      stack.style.setProperty("--stack-max-width", isRequestColumn ? "100%" : "160px");
      el.appendChild(stack);

      grid.appendChild(el);
      return { pattern: p, cell: el, stack };
    });

    const byPattern = new Map(PATTERNS.map(p => [p.key, []]));
    for(const c of CARDS){
      for(const pk of c.patterns){
        if(byPattern.has(pk)) byPattern.get(pk).push(c);
      }
    }

    // Render cards into each column cell
    for(const {pattern, stack} of cells){
      const items = byPattern.get(pattern.key) || [];
      // Sort stable by name for readability
      items.sort((a,b) => a.name.localeCompare(b.name));
      for(const item of items){
        stack.appendChild(renderCard(item, pattern));
      }
    }

    function renderCard(item, pattern){
      const card = document.createElement("button");
      card.type = "button";
      card.className = "card";
      card.style.setProperty("--card-color", `var(${pattern.colorVar})`);
      card.setAttribute("title", item.tip);
      card.dataset.cardId = item.id;
      card.dataset.pattern = pattern.key;

      const bar = document.createElement("div");
      bar.className = "bar";
      bar.style.background = `var(${pattern.colorVar})`;
      card.appendChild(bar);

      const row = document.createElement("div");
      row.className = "row";
      const name = document.createElement("div");
      name.className = "name";
      name.textContent = item.name;

      const abbr = document.createElement("div");
      abbr.className = "abbr";
      abbr.textContent = item.abbr;

      row.appendChild(name);
      row.appendChild(abbr);
      card.appendChild(row);

      const desc = document.createElement("div");
      desc.className = "desc";
      desc.textContent = item.detail.what;
      card.appendChild(desc);

      card.addEventListener("click", () => {
        const rect = card.getBoundingClientRect();
        openModal(item, pattern, rect);
      });
      return card;
    }

    // Modal wiring
    const dlg = document.getElementById("detailDialog");
    const modalTitle = document.getElementById("modalTitle");
    const modalMeta = document.getElementById("modalMeta");
    const modalWhat = document.getElementById("modalWhat");
    const modalFit = document.getElementById("modalFit");
    const modalUse = document.getElementById("modalUse");
    const closeBtn = document.getElementById("closeBtn");
    const modalShell = dlg.querySelector(".modal");

    function openModal(item, pattern, sourceRect){
      modalTitle.textContent = item.name;
      modalMeta.textContent = `Opened from pattern: ${pattern.label} | Card key: ${item.abbr}`;
      modalWhat.textContent = item.detail.what;

      fillList(modalFit, item.detail.fit || []);
      fillList(modalUse, item.detail.use || []);

      if(typeof dlg.showModal === "function"){
        dlg.showModal();
        requestAnimationFrame(() => animateModalOpening(sourceRect));
      }
      else alert(item.name + "\n\n" + item.detail.what);
    }

    function fillList(el, lines){
      el.innerHTML = "";
      for(const line of lines){
        const li = document.createElement("li");
        li.textContent = line;
        el.appendChild(li);
      }
      if(lines.length === 0){
        const li = document.createElement("li");
        li.textContent = "No notes yet.";
        el.appendChild(li);
      }
    }

    closeBtn.addEventListener("click", () => dlg.close());
    dlg.addEventListener("click", (e) => {
      // close when clicking backdrop
      const rect = dlg.getBoundingClientRect();
      const inDialog = e.clientX >= rect.left && e.clientX <= rect.right &&
                       e.clientY >= rect.top && e.clientY <= rect.bottom;
      if(!inDialog) dlg.close();
    });

    function animateModalOpening(sourceRect){
      if(!sourceRect || !modalShell || typeof modalShell.animate !== "function") return;
      const modalRect = modalShell.getBoundingClientRect();
      const originX = clamp(((sourceRect.left + sourceRect.width / 2) - modalRect.left) / modalRect.width);
      const originY = clamp(((sourceRect.top + sourceRect.height / 2) - modalRect.top) / modalRect.height);
      const origin = `${originX * 100}% ${originY * 100}%`;

      modalShell.animate(
        [
          { transformOrigin: origin, transform: "scale(0.6)", opacity: 0, filter: "blur(6px)" },
          { transformOrigin: origin, transform: "scale(1)", opacity: 1, filter: "blur(0)" }
        ],
        {
          duration: 360,
          easing: "cubic-bezier(0.16, 1, 0.3, 1)"
        }
      );
    }

    function clamp(value, min = 0, max = 1){
      return Math.min(Math.max(value, min), max);
    }

    // ðŸ˜¼ Quick critical-thinking hooks (optional): uncomment to see pattern overlaps in console
    // console.table(CARDS.map(c => ({ name: c.name, patterns: c.patterns.join(", ") })));
  </script>
</body>
</html>
